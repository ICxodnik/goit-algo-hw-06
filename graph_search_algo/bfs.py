from collections import deque

def bfs_iterative(graph, start):
    # Ініціалізація порожньої множини для зберігання відвіданих вершин
    visited = set()
    # Ініціалізація черги з початковою вершиною
    queue = deque([start])

    while queue:  # Поки черга не порожня, продовжуємо обхід
        # Вилучаємо першу вершину з черги
        vertex = queue.popleft()
        # Перевіряємо, чи була вершина відвідана раніше
        if vertex not in visited:
            # Якщо не була відвідана, друкуємо її
            print(vertex, end=" ")
            # Додаємо вершину до множини відвіданих вершин
            visited.add(vertex)
            # Додаємо всіх невідвіданих сусідів вершини до кінця черги
            # Операція різниці множин вилучає вже відвідані вершини зі списку сусідів
            queue.extend(set(graph[vertex]) - visited)
    # Повертаємо множину відвіданих вершин після завершення обходу
    return visited 
     
if __name__ == "__main__":

    graph = {
        'Головна': {'Кловська': 2, 'Палац Спорту': 3},
        'Кловська': {'Головна': 2, 'Палац Спорту': 2, 'Арсенальна': 4},
        'Палац Спорту': {'Головна': 3, 'Кловська': 2, 'Печерська': 4},
        'Печерська': {'Палац Спорту': 4, 'Арсенальна': 3, 'Либідська': 5},
        'Арсенальна': {'Кловська': 4, 'Печерська': 3},
        'Либідська': {'Печерська': 5, 'Дружби Народів': 6},
        'Дружби Народів': {'Либідська': 6, 'Голосіївська': 4},
        'Голосіївська': {'Дружби Народів': 4, 'Виставковий центр': 3},
        'Виставковий центр': {'Голосіївська': 3}
    }

    bfs_iterative(graph, 'Головна')
